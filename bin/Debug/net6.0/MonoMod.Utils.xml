<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MonoMod.Utils</name>
    </assembly>
    <members>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
                Reserved to be used by the compiler for tracking metadata.
                This class should not be used by developers in source code.
            </summary>
            <remarks>
                This definition is provided by the <i>IsExternalInit</i> NuGet package (https://www.nuget.org/packages/IsExternalInit).
                Please see https://github.com/manuelroemer/IsExternalInit for more information.
            </remarks>
        </member>
        <member name="T:MonoMod.Utils.Cil.CecilILGenerator">
            <summary>
            A variant of ILGenerator which uses Mono.Cecil under the hood.
            </summary>
        </member>
        <member name="P:MonoMod.Utils.Cil.CecilILGenerator.IL">
            <summary>
            The underlying Mono.Cecil.Cil.ILProcessor.
            </summary>
        </member>
        <member name="T:MonoMod.Utils.Cil.ILGeneratorShim">
            <summary>
            Abstract version of System.Reflection.Emit.ILGenerator. See <see cref="T:System.Reflection.Emit.ILGenerator"/> for proper documentation.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Cil.ILGeneratorShim.GetProxy">
            <summary>
            Get a "real" ILGenerator for this ILGeneratorShim.
            </summary>
            <returns>A "real" ILGenerator.</returns>
        </member>
        <member name="M:MonoMod.Utils.Cil.ILGeneratorShim.GetProxyType``1">
            <summary>
            Get the proxy type for a given ILGeneratorShim type. The proxy type implements ILGenerator.
            </summary>
            <typeparam name="TShim">The ILGeneratorShim type.</typeparam>
            <returns>The "real" ILGenerator type.</returns>
        </member>
        <member name="M:MonoMod.Utils.Cil.ILGeneratorShim.GetProxyType(System.Type)">
            <summary>
            Get the proxy type for a given ILGeneratorShim type. The proxy type implements ILGenerator.
            </summary>
            <param name="tShim">The ILGeneratorShim type.</param>
            <returns>The "real" ILGenerator type.</returns>
        </member>
        <member name="P:MonoMod.Utils.Cil.ILGeneratorShim.GenericProxyType">
            <summary>
            Get the (open) generic proxy type implementing ILGenerator.
            </summary>
            <returns>The "real" ILGenerator type, non-generic.</returns>
        </member>
        <member name="T:MonoMod.Utils.DMDGenerator`1">
            <summary>
            A DynamicMethodDefinition "generator", responsible for generating a runtime MethodInfo from a DMD MethodDefinition.
            </summary>
            <typeparam name="TSelf">The derived type.</typeparam>
        </member>
        <member name="T:MonoMod.Utils.DMDCecilGenerator">
            <summary>
            A DMDGenerator implementation using Mono.Cecil to build an in-memory assembly.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.DynDll.OpenLibrary(System.String,System.Boolean)">
            <summary>
            Open a given library and get its handle.
            </summary>
            <param name="name">The library name.</param>
            <param name="skipMapping">Whether to skip using the mapping or not.</param>
            <returns>The library handle.</returns>
        </member>
        <member name="M:MonoMod.Utils.DynDll.TryOpenLibrary(System.String,System.IntPtr@,System.Boolean)">
            <summary>
            Try to open a given library and get its handle.
            </summary>
            <param name="name">The library name.</param>
            <param name="libraryPtr">The library handle, or null if it failed loading.</param>
            <param name="skipMapping">Whether to skip using the mapping or not.</param>
            <returns>True if the handle was obtained, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.DynDll.CloseLibrary(System.IntPtr)">
            <summary>
            Release a library handle obtained via OpenLibrary. Don't release the result of OpenLibrary(null)!
            </summary>
            <param name="lib">The library handle.</param>
        </member>
        <member name="M:MonoMod.Utils.DynDll.GetFunction(System.IntPtr,System.String)">
            <summary>
            Get a function pointer for a function in the given library.
            </summary>
            <param name="libraryPtr">The library handle.</param>
            <param name="name">The function name.</param>
            <returns>The function pointer.</returns>
        </member>
        <member name="M:MonoMod.Utils.DynDll.TryGetFunction(System.IntPtr,System.String,System.IntPtr@)">
            <summary>
            Get a function pointer for a function in the given library.
            </summary>
            <param name="libraryPtr">The library handle.</param>
            <param name="name">The function name.</param>
            <param name="functionPtr">The function pointer, or null if it wasn't found.</param>
            <returns>True if the function pointer was obtained, false otherwise.</returns>
        </member>
        <member name="F:MonoMod.Utils.DynDll.Mappings">
            <summary>
            Allows you to remap library paths / names and specify loading flags. Useful for cross-platform compatibility. Applies only to DynDll.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.DynDll.AsDelegate``1(System.IntPtr)">
            <summary>
            Extension method wrapping Marshal.GetDelegateForFunctionPointer
            </summary>
        </member>
        <member name="M:MonoMod.Utils.DynDll.ResolveDynDllImports(System.Type,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{MonoMod.Utils.DynDllMapping}})">
            <summary>
            Fill all static delegate fields with the DynDllImport attribute.
            Call this early on in the static constructor.
            </summary>
            <param name="type">The type containing the DynDllImport delegate fields.</param>
            <param name="mappings">Any optional mappings similar to the static mappings.</param>
        </member>
        <member name="M:MonoMod.Utils.DynDll.ResolveDynDllImports(System.Object,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{MonoMod.Utils.DynDllMapping}})">
            <summary>
            Fill all instance delegate fields with the DynDllImport attribute.
            Call this early on in the constructor.
            </summary>
            <param name="instance">An instance of a type containing the DynDllImport delegate fields.</param>
            <param name="mappings">Any optional mappings similar to the static mappings.</param>
        </member>
        <member name="T:MonoMod.Utils.DynDllImportAttribute">
            <summary>
            Similar to DllImport, but requires you to run typeof(DeclaringType).ResolveDynDllImports();
            </summary>
        </member>
        <member name="P:MonoMod.Utils.DynDllImportAttribute.LibraryName">
            <summary>
            The library or library alias to use.
            </summary>
        </member>
        <member name="P:MonoMod.Utils.DynDllImportAttribute.EntryPoints">
            <summary>
            A list of possible entrypoints that the function can be resolved to. Implicitly includes the field name and delegate name.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.DynDllImportAttribute.#ctor(System.String,System.String[])">
            <param name="libraryName">The library or library alias to use.</param>
            <param name="entryPoints">A list of possible entrypoints that the function can be resolved to. Implicitly includes the field name and delegate name.</param>
        </member>
        <member name="T:MonoMod.Utils.DynDllMapping">
            <summary>
            A mapping entry, to be used by <see cref="T:MonoMod.Utils.DynDllImportAttribute"/>.
            </summary>
        </member>
        <member name="P:MonoMod.Utils.DynDllMapping.LibraryName">
            <summary>
            The name as which the library will be resolved as. Useful to remap libraries or to provide full paths.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.DynDllMapping.#ctor(System.String)">
            <param name="libraryName">The name as which the library will be resolved as. Useful to remap libraries or to provide full paths.</param>
        </member>
        <member name="T:MonoMod.Utils.Extensions">
            <summary>
            Collection of extensions used by MonoMod and other projects.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.SafeResolve(Mono.Cecil.TypeReference)">
            <summary>
            Safely resolve a reference, silently discarding any exceptions.
            </summary>
            <param name="r">The reference to resolve.</param>
            <returns>The resolved definition or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.SafeResolve(Mono.Cecil.FieldReference)">
            <summary>
            Safely resolve a reference, silently discarding any exceptions.
            </summary>
            <param name="r">The reference to resolve.</param>
            <returns>The resolved definition or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.SafeResolve(Mono.Cecil.MethodReference)">
            <summary>
            Safely resolve a reference, silently discarding any exceptions.
            </summary>
            <param name="r">The reference to resolve.</param>
            <returns>The resolved definition or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.SafeResolve(Mono.Cecil.PropertyReference)">
            <summary>
            Safely resolve a reference, silently discarding any exceptions.
            </summary>
            <param name="r">The reference to resolve.</param>
            <returns>The resolved definition or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetCustomAttribute(Mono.Cecil.ICustomAttributeProvider,System.String)">
            <summary>
            Get a certain custom attribute from an attribute provider.
            </summary>
            <param name="cap">The attribute provider.</param>
            <param name="attribute">The custom attribute name.</param>
            <returns>The first matching custom attribute, or null if no matching attribute has been found.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.HasCustomAttribute(Mono.Cecil.ICustomAttributeProvider,System.String)">
            <summary>
            Determine if an attribute provider has got a specific custom attribute.
            </summary>
            <param name="cap">The attribute provider.</param>
            <param name="attribute">The custom attribute name.</param>
            <returns>true if the attribute provider contains the given custom attribute, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetInt(Mono.Cecil.Cil.Instruction)">
            <summary>
            Get the integer value pushed onto the stack with this instruction.
            </summary>
            <param name="instr">The instruction to get the pushed integer value for.</param>
            <returns>The pushed integer value.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetIntOrNull(Mono.Cecil.Cil.Instruction)">
            <summary>
            Get the integer value pushed onto the stack with this instruction.
            </summary>
            <param name="instr">The instruction to get the pushed integer value for.</param>
            <returns>The pushed integer value or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.IsBaseMethodCall(Mono.Cecil.Cil.MethodBody,Mono.Cecil.MethodReference)">
            <summary>
            Determine if the method call is a base method call.
            </summary>
            <param name="body">The caller method body.</param>
            <param name="called">The called method.</param>
            <returns>True if the called method is a base method of the caller method, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.IsCallvirt(Mono.Cecil.MethodReference)">
            <summary>
            Determine if the given method can be preferably called using callvirt.
            </summary>
            <param name="method">The called method.</param>
            <returns>True if the called method can be called using callvirt, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.IsStruct(Mono.Cecil.TypeReference)">
            <summary>
            Determine if the given type is a struct (also known as "value type") or struct-alike (f.e. primitive).
            </summary>
            <param name="type">The type to check.</param>
            <returns>True if the type is a struct, primitive or similar, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.ToLongOp(Mono.Cecil.Cil.OpCode)">
            <summary>
            Get the long form opcode for any short form opcode.
            </summary>
            <param name="op">The short form opcode.</param>
            <returns>The long form opcode.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.ToShortOp(Mono.Cecil.Cil.OpCode)">
            <summary>
            Get the short form opcode for any long form opcode.
            </summary>
            <param name="op">The long form opcode.</param>
            <returns>The short form opcode.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.RecalculateILOffsets(Mono.Cecil.MethodDefinition)">
            <summary>
            Calculate updated instruction offsets. Required for certain manual fixes.
            </summary>
            <param name="method">The method to recalculate the IL instruction offsets for.</param>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FixShortLongOps(Mono.Cecil.MethodDefinition)">
            <summary>
            Fix (and optimize) any instructions which should use the long / short form opcodes instead.
            </summary>
            <param name="method">The method to apply the fixes to.</param>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Is(System.Reflection.MemberInfo,Mono.Cecil.MemberReference)">
            <summary>
            Check if the signatures of a given System.Reflection and Mono.Cecil member reference match.
            </summary>
            <param name="minfo">The System.Reflection member reference.</param>
            <param name="mref">The Mono.Cecil member reference.</param>
            <returns>True if both references share the same signature, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Is(Mono.Cecil.MemberReference,System.Reflection.MemberInfo)">
            <summary>
            Check if the signatures of a given System.Reflection and Mono.Cecil member reference match.
            </summary>
            <param name="mref">The Mono.Cecil member reference.</param>
            <param name="minfo">The System.Reflection member reference.</param>
            <returns>True if both references share the same signature, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.AddRange``1(Mono.Collections.Generic.Collection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            See <see cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.AddRange(System.Collections.IDictionary,System.Collections.IDictionary)">
            <summary>
            See <see cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            See <see cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.AddRange``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            See <see cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.InsertRange``1(Mono.Collections.Generic.Collection{``0},System.Int32,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            See <see cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.IsCompatible(System.Type,System.Type)">
            <summary>
            Determine if two types are compatible with each other (f.e. object with string, or enums with their underlying integer type).
            </summary>
            <param name="type">The first type.</param>
            <param name="other">The second type.</param>
            <returns>True if both types are compatible with each other, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.CreateDelegate``1(System.Reflection.MethodBase)">
            <summary>
            Creates a delegate of the specified type from this method.
            </summary>
            <param name="method">The method to create the delegate from.</param>
            <typeparam name="T">The type of the delegate to create.</typeparam>
            <returns>The delegate for this method.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.CreateDelegate``1(System.Reflection.MethodBase,System.Object)">
            <summary>
            Creates a delegate of the specified type with the specified target from this method.
            </summary>
            <param name="method">The method to create the delegate from.</param>
            <typeparam name="T">The type of the delegate to create.</typeparam>
            <param name="target">The object targeted by the delegate.</param>
            <returns>The delegate for this method.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.CreateDelegate(System.Reflection.MethodBase,System.Type)">
            <summary>
            Creates a delegate of the specified type from this method.
            </summary>
            <param name="method">The method to create the delegate from.</param>
            <param name="delegateType">The type of the delegate to create.</param>
            <returns>The delegate for this method.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.CreateDelegate(System.Reflection.MethodBase,System.Type,System.Object)">
            <summary>
            Creates a delegate of the specified type with the specified target from this method.
            </summary>
            <param name="method">The method to create the delegate from.</param>
            <param name="delegateType">The type of the delegate to create.</param>
            <param name="target">The object targeted by the delegate.</param>
            <returns>The delegate for this method.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindMethod(Mono.Cecil.TypeDefinition,System.String,System.Boolean)">
            <summary>
            Find a method for a given ID.
            </summary>
            <param name="type">The type to search in.</param>
            <param name="id">The method ID.</param>
            <param name="simple">Whether to perform a simple search pass as well or not.</param>
            <returns>The first matching method or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindMethodDeep(Mono.Cecil.TypeDefinition,System.String,System.Boolean)">
            <summary>
            Find a method for a given ID recursively (including the passed type's base types).
            </summary>
            <param name="type">The type to search in.</param>
            <param name="id">The method ID.</param>
            <param name="simple">Whether to perform a simple search pass as well or not.</param>
            <returns>The first matching method or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindMethod(System.Type,System.String,System.Boolean)">
            <summary>
            Find a method for a given ID.
            </summary>
            <param name="type">The type to search in.</param>
            <param name="id">The method ID.</param>
            <param name="simple">Whether to perform a simple search pass as well or not.</param>
            <returns>The first matching method or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindMethodDeep(System.Type,System.String,System.Boolean)">
            <summary>
            Find a method for a given ID recursively (including the passed type's base types).
            </summary>
            <param name="type">The type to search in.</param>
            <param name="id">The method ID.</param>
            <param name="simple">Whether to perform a simple search pass as well or not.</param>
            <returns>The first matching method or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindProperty(Mono.Cecil.TypeDefinition,System.String)">
            <summary>
            Find a property for a given name.
            </summary>
            <param name="type">The type to search in.</param>
            <param name="name">The property name.</param>
            <returns>The first matching property or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindPropertyDeep(Mono.Cecil.TypeDefinition,System.String)">
            <summary>
            Find a property for a given name recursively (including the passed type's base types).
            </summary>
            <param name="type">The type to search in.</param>
            <param name="name">The property name.</param>
            <returns>The first matching property or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindField(Mono.Cecil.TypeDefinition,System.String)">
            <summary>
            Find a field for a given name.
            </summary>
            <param name="type">The type to search in.</param>
            <param name="name">The field name.</param>
            <returns>The first matching field or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindFieldDeep(Mono.Cecil.TypeDefinition,System.String)">
            <summary>
            Find a field for a given name recursively (including the passed type's base types).
            </summary>
            <param name="type">The type to search in.</param>
            <param name="name">The field name.</param>
            <returns>The first matching field or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindEvent(Mono.Cecil.TypeDefinition,System.String)">
            <summary>
            Find an event for a given name.
            </summary>
            <param name="type">The type to search in.</param>
            <param name="name">The event name.</param>
            <returns>The first matching event or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.FindEventDeep(Mono.Cecil.TypeDefinition,System.String)">
            <summary>
            Find an event for a given name recursively (including the passed type's base types).
            </summary>
            <param name="type">The type to search in.</param>
            <param name="name">The event name.</param>
            <returns>The first matching event or null.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetID(Mono.Cecil.MethodReference,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Get a reference ID that is similar to the full name, but consistent between System.Reflection and Mono.Cecil.
            </summary>
            <param name="method">The method to get the ID for.</param>
            <param name="name">The name to use instead of the reference's own name.</param>
            <param name="type">The ID to use instead of the reference's declaring type ID.</param>
            <param name="withType">Whether the type ID should be included or not. System.Reflection avoids it by default.</param>
            <param name="simple">Whether the ID should be "simple" (name only).</param>
            <returns>The ID.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetID(Mono.Cecil.CallSite)">
            <summary>
            Get a reference ID that is similar to the full name, but consistent between System.Reflection and Mono.Cecil.
            </summary>
            <param name="method">The call site to get the ID for.</param>
            <returns>The ID.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetID(System.Reflection.MethodBase,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Get a reference ID that is similar to the full name, but consistent between System.Reflection and Mono.Cecil.
            </summary>
            <param name="method">The method to get the ID for.</param>
            <param name="name">The name to use instead of the reference's own name.</param>
            <param name="type">The ID to use instead of the reference's declaring type ID.</param>
            <param name="withType">Whether the type ID should be included or not. System.Reflection avoids it by default.</param>
            <param name="proxyMethod">Whether the method is regarded as a proxy method or not. Setting this paramater to true will skip the first parameter.</param>
            <param name="simple">Whether the ID should be "simple" (name only).</param>
            <returns>The ID.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetPatchName(Mono.Cecil.MemberReference)">
            <summary>
            Get the "patch name" - the name of the target to patch - for the given member.
            </summary>
            <param name="mr">The member to get the patch name for.</param>
            <returns>The patch name.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetPatchFullName(Mono.Cecil.MemberReference)">
            <summary>
            Get the "patch name" - the name of the target to patch - for the given member.
            </summary>
            <param name="mr">The member to get the patch name for.</param>
            <returns>The patch name.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Clone(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodDefinition)">
            <summary>
            Clone the given method definition.
            </summary>
            <param name="o">The original method.</param>
            <param name="c">The method definition to apply the cloning process onto, or null to create a new method.</param>
            <returns>A clone of the original method.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Clone(Mono.Cecil.Cil.MethodBody,Mono.Cecil.MethodDefinition)">
            <summary>
            Clone the given method body.
            </summary>
            <param name="bo">The original method body.</param>
            <param name="m">The method which will own the newly cloned method body.</param>
            <returns>A clone of the original method body.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Update(Mono.Cecil.GenericParameter,System.Int32,Mono.Cecil.GenericParameterType)">
            <summary>
            Force-update a generic parameter's position and type.
            </summary>
            <param name="param">The generic parameter to update.</param>
            <param name="position">The new position.</param>
            <param name="type">The new type.</param>
            <returns>The updated generic parameter.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.ResolveGenericParameter(Mono.Cecil.IGenericParameterProvider,Mono.Cecil.GenericParameter)">
            <summary>
            Resolve a given generic parameter in another context.
            </summary>
            <param name="provider">The new context.</param>
            <param name="orig">The original generic parameter.</param>
            <returns>A generic parameter provided by the given context which matches the original generic parameter.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.IMetadataTokenProvider,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given member reference (metadata token provider).
            </summary>
            <param name="mtp">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.TypeReference,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given type reference.
            </summary>
            <param name="type">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.GenericParameterConstraint,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given type reference.
            </summary>
            <param name="constraint">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.MethodReference,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given method reference.
            </summary>
            <param name="method">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.CallSite,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given callsite.
            </summary>
            <param name="method">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.FieldReference,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given field reference.
            </summary>
            <param name="field">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.ParameterDefinition,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given parameter definition.
            </summary>
            <param name="param">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Clone(Mono.Cecil.ParameterDefinition)">
            <summary>
            Clone the given parameter definition.
            </summary>
            <param name="param">The original parameter definition.</param>
            <returns>A clone of the original parameter definition.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.CustomAttribute,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given custom attribute.
            </summary>
            <param name="attrib">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Clone(Mono.Cecil.CustomAttribute)">
            <summary>
            Clone the given custom attribute.
            </summary>
            <param name="attrib">The original custom attribute.</param>
            <returns>A clone of the original custom attribute.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Relink(Mono.Cecil.GenericParameter,MonoMod.Utils.Relinker,Mono.Cecil.IGenericParameterProvider)">
            <summary>
            Relink the given generic parameter reference.
            </summary>
            <param name="param">The reference to relink.</param>
            <param name="relinker">The relinker to use during the relinking process.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.Clone(Mono.Cecil.GenericParameter)">
            <summary>
            Clone the given generic parameter.
            </summary>
            <param name="param">The original generic parameter.</param>
            <returns>A clone of the original generic parameter.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetManagedSize(System.Type)">
            <summary>
            Get the managed size of a given type. This matches an IL-level sizeof(t), even if it cannot be determined normally in C#.
            Note that <c>sizeof(t) != Marshal.SizeOf(t)</c>, f.e. when t is char.
            </summary>
            <remarks>
            An IL-level <c>sizeof(t)</c> will return <c>sizeof(IntPtr)</c> for reference types, as it refers to the size on stack or in an object,
            not the size on heap.
            </remarks>
            <param name="t">The type to get the size from.</param>
            <returns>The managed type size.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetThisParamType(System.Reflection.MethodBase)">
            <summary>
            Get a type which matches what the method should receive via ldarg.0
            </summary>
            <param name="method">The method to obtain the "this" parameter type from.</param>
            <returns>The "this" parameter type.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetLdftnPointer(System.Reflection.MethodBase)">
            <summary>
            Get a native function pointer for a given method. This matches an IL-level ldftn.
            </summary>
            <remarks>
            The result of ldftn doesn't always match that of MethodHandle.GetFunctionPointer().
            For example, ldftn doesn't JIT-compile the method on mono, which thus keeps the class constructor untouched.
            And on .NET, struct overrides (f.e. ToString) have got multiple entry points pointing towards the same code.
            </remarks>
            <param name="m">The method to get a native function pointer for.</param>
            <returns>The native function pointer.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.ToHexadecimalString(System.Byte[])">
            <summary>
            Create a hexadecimal string for the given bytes.
            </summary>
            <param name="data">The input bytes.</param>
            <returns>The output hexadecimal string.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.InvokePassing``1(System.MulticastDelegate,``0,System.Object[])">
            <summary>
            Invokes all delegates in the invocation list, passing on the result to the next.
            </summary>
            <typeparam name="T">Type of the result.</typeparam>
            <param name="md">The multicast delegate.</param>
            <param name="val">The initial value and first parameter.</param>
            <param name="args">Any other arguments that may be passed.</param>
            <returns>The result of all delegates.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.InvokeWhileTrue(System.MulticastDelegate,System.Object[])">
            <summary>
            Invokes all delegates in the invocation list, as long as the previously invoked delegate returns true.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.InvokeWhileFalse(System.MulticastDelegate,System.Object[])">
            <summary>
            Invokes all delegates in the invocation list, as long as the previously invoked delegate returns false.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.InvokeWhileNull``1(System.MulticastDelegate,System.Object[])">
            <summary>
            Invokes all delegates in the invocation list, as long as the previously invoked delegate returns null.
            </summary>
        </member>
        <member name="M:MonoMod.Utils.Extensions.SpacedPascalCase(System.String)">
            <summary>
            Split PascalCase words to become Pascal Case instead.
            </summary>
            <param name="input">PascalCaseString</param>
            <returns>Pascal Case String</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.ReadNullTerminatedString(System.IO.BinaryReader)">
            <summary>
            Read the string from the BinaryReader BinaryWriter in a C-friendly format.
            </summary>
            <param name="stream">The input which the method reads from.</param>
            <returns>The output string.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.WriteNullTerminatedString(System.IO.BinaryWriter,System.String)">
            <summary>
            Write the string to the BinaryWriter in a C-friendly format.
            </summary>
            <param name="stream">The output which the method writes to.</param>
            <param name="text">The input string.</param>
        </member>
        <member name="M:MonoMod.Utils.Extensions.CastDelegate``1(System.Delegate)">
            <summary>
            Cast a delegate from one type to another. Compatible with delegates holding an invocation list (combined delegates).
            </summary>
            <param name="source">The input delegate.</param>
            <returns>The output delegate.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.CastDelegate(System.Delegate,System.Type)">
            <summary>
            Cast a delegate from one type to another. Compatible with delegates holding an invocation list (combined delegates).
            </summary>
            <param name="source">The input delegate.</param>
            <param name="type">The wanted output delegate type.</param>
            <returns>The output delegate.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetStateMachineTarget(System.Reflection.MethodInfo)">
            <summary>
            Get the method of interest for a given state machine method.
            </summary>
            <param name="method">The method creating the state machine.</param>
            <returns>The "main" method in the state machine.</returns>
        </member>
        <member name="M:MonoMod.Utils.Extensions.GetActualGenericMethodDefinition(System.Reflection.MethodInfo)">
            <summary>
            Gets the <i>actual</i> generic method definition of a method, as defined on the fully open type.
            </summary>
            <param name="method">The potentially instantiated method to find the definition of.</param>
            <returns>The original method definition, with no generic arguments filled in.</returns>
        </member>
        <member name="T:MonoMod.Utils.Relinker">
            <summary>
            The relinker callback delegate type.
            </summary>
            <param name="mtp">The reference (metadata token provider) to relink.</param>
            <param name="context">The generic context provided to relink generic references.</param>
            <returns>A relinked reference.</returns>
        </member>
        <member name="T:MonoMod.Cil.ILContext">
            <summary>
            An IL manipulation "context" with various helpers and direct access to the MethodBody.
            </summary>
        </member>
        <member name="T:MonoMod.Cil.ILContext.Manipulator">
            <summary>
            The manipulator callback, accepted by the Invoke method.
            </summary>
            <param name="il"></param>
        </member>
        <member name="P:MonoMod.Cil.ILContext.Method">
            <summary>
            The manipulated method.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILContext.IL">
            <summary>
            The manipulated method's IL processor.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILContext.Body">
            <summary>
            The manipulated method body.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILContext.Module">
            <summary>
            The manipulated method's module.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILContext.Instrs">
            <summary>
            The manipulated method instructions.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILContext.Labels">
            <summary>
            A readonly list of all defined labels.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILContext.IsReadOnly">
            <summary>
            Has the context been made read-only? No further method access is possible, but the context has not yet been disposed.
            </summary>
        </member>
        <member name="E:MonoMod.Cil.ILContext.OnDispose">
            <summary>
            Events which run when the context will be disposed.
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILContext.Invoke(MonoMod.Cil.ILContext.Manipulator)">
            <summary>
            Invoke a given manipulator callback.
            </summary>
            <param name="manip">The manipulator to run in this context.</param>
        </member>
        <member name="M:MonoMod.Cil.ILContext.MakeReadOnly">
            <summary>
            Mark this ILContext as read-only and prevent this context from further accessing the originally passed method.
            </summary>
            <remarks>
            If the method is altered prior to calling MakeReadOnly or afterwards by accessing the method directly, the results are undefined.
            </remarks>
        </member>
        <member name="M:MonoMod.Cil.ILContext.Import(System.Reflection.FieldInfo)">
            <summary>
            See <see cref="M:Mono.Cecil.ModuleDefinition.ImportReference(System.Reflection.FieldInfo)"/>
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILContext.Import(System.Reflection.MethodBase)">
            <summary>
            See <see cref="M:Mono.Cecil.ModuleDefinition.ImportReference(System.Reflection.MethodBase)"/>
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILContext.Import(System.Type)">
            <summary>
            See <see cref="M:Mono.Cecil.ModuleDefinition.ImportReference(System.Type)"/>
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILContext.DefineLabel">
            <summary>
            Define a new label to be marked with a cursor.
            </summary>
            <returns>A label without a target instruction.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILContext.DefineLabel(Mono.Cecil.Cil.Instruction)">
            <summary>
            Define a new label pointing at a given instruction.
            </summary>
            <param name="target">The instruction the label will point at.</param>
            <returns>A label pointing at the given instruction.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILContext.IndexOf(Mono.Cecil.Cil.Instruction)">
            <summary>
            Determine the index of a given instruction.
            </summary>
            <param name="instr">The instruction to get the index of.</param>
            <returns>The instruction index, or the end of the method body if it hasn't been found.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILContext.GetIncomingLabels(Mono.Cecil.Cil.Instruction)">
            <summary>
            Obtain all labels pointing at the given instruction.
            </summary>
            <param name="instr">The instruction to get all labels for.</param>
            <returns>All labels targeting the given instruction.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILContext.AddReference``1(``0@)">
            <summary>
            Bind an arbitary object to an ILContext for static retrieval.
            </summary>
            <typeparam name="T">The type of the object. The combination of typeparam and id provides the unique static reference.</typeparam>
            <param name="value">The object to store.</param>
            <returns>The id to use in combination with the typeparam for object retrieval.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILContext.ToString">
            <summary>
            Obtain a string representation of this context (method ID and body).
            </summary>
            <returns>A string representation of this context.</returns>
        </member>
        <member name="T:MonoMod.Cil.MoveType">
            <summary>
            Specifies where a ILCursor should be positioned in relation to the target of a search function
            </summary>
        </member>
        <member name="F:MonoMod.Cil.MoveType.Before">
            <summary>
             Move the cursor before the first instruction in the match
            </summary>
        </member>
        <member name="F:MonoMod.Cil.MoveType.AfterLabel">
            <summary>
            Equivalent to Before with `cursor.MoveAfterLabels()` causing emitted instructions to become the target of incoming labels
            </summary>
        </member>
        <member name="F:MonoMod.Cil.MoveType.After">
            <summary>
             Move the cursor after the last instruction in the match
            </summary>
        </member>
        <member name="T:MonoMod.Cil.SearchTarget">
            <summary>
            Indicates whether the position of a ILCursor is the result of a search function and 
            if the next search should ignore the instruction preceeding or following this cursor.
            <para />
            SearchTarget.Next is the result of searching with MoveType.Before, and SearchTarget.Prev from MoveType.After 
            </summary>
        </member>
        <member name="F:MonoMod.Cil.SearchTarget.Next">
            <summary>
            A foward searching function cannot match the Next instruction and must move the cursor forward
            </summary>
        </member>
        <member name="F:MonoMod.Cil.SearchTarget.Prev">
            <summary>
            A reverse searching function cannot match the Next instruction and must move the cursor backward
            </summary>
        </member>
        <member name="T:MonoMod.Cil.ILCursor">
            <summary>
            A cursor used to manipulate a method body in an ILContext.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Context">
            <summary>
            The context to which this cursor belongs to.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Next">
            <summary>
            The instruction immediately following the cursor position or null if the cursor is at the end of the instruction list.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Prev">
            <summary>
            The instruction immediately preceding the cursor position or null if the cursor is at the start of the instruction list.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Previous">
            <summary>
            The instruction immediately preceding the cursor position or null if the cursor is at the start of the instruction list.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Index">
            <summary>
            The index of the instruction immediately following the cursor position. Range: 0 to <c>Instrs.Count</c>
            Setter accepts negative indexing by adding <c>Instrs.Count</c> to the operand
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.SearchTarget">
            <summary>
            Indicates whether the position of a MMILCursor is the result of a search function and 
            if the next search should ignore the instruction preceeding or following this cursor.
            
            See <see cref="T:MonoMod.Cil.SearchTarget"/>
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.IncomingLabels">
            <summary>
            Enumerates all labels which point to the current instruction (<c>label.Target == Next</c>)
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Method">
            <summary>
            See <see cref="P:MonoMod.Cil.ILContext.Method"/>
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.IL">
            <summary>
            See <see cref="P:MonoMod.Cil.ILContext.IL"/>
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Body">
            <summary>
            See <see cref="P:MonoMod.Cil.ILContext.Body"/>
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Module">
            <summary>
            See <see cref="P:MonoMod.Cil.ILContext.Module"/>
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILCursor.Instrs">
            <summary>
            See <see cref="P:MonoMod.Cil.ILContext.Instrs"/>
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Clone">
            <summary>
            Create a clone of this cursor.
            </summary>
            <returns>The cloned cursor.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.IsBefore(Mono.Cecil.Cil.Instruction)">
            <summary>
            Is this cursor before the given instruction?
            </summary>
            <param name="instr">The instruction to check.</param>
            <returns>True if this cursor is before the given instruction, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.IsAfter(Mono.Cecil.Cil.Instruction)">
            <summary>
            Is this cursor after the given instruction?
            </summary>
            <param name="instr">The instruction to check.</param>
            <returns>True if this cursor is after the given instruction, false otherwise.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.ToString">
            <summary>
            Obtain a string representation of this cursor (method ID, index, search target, surrounding instructions).
            </summary>
            <returns>A string representation of this cursor.</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Goto(Mono.Cecil.Cil.Instruction,MonoMod.Cil.MoveType,System.Boolean)">
            <summary>
            Move the cursor to a target instruction. All other movements go through this.
            </summary>
            <param name="insn">The target instruction</param>
            <param name="moveType">Where to move in relation to the target instruction and incoming labels (branches)</param>
            <param name="setTarget">Whether to set the `SearchTarget` and skip the target instruction with the next search function</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.MoveAfterLabels">
            <summary>
            Move the cursor after incoming labels (branches). If an instruction is emitted, all labels which currently point to Next, will point to the newly emitted instruction.
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.MoveBeforeLabels">
            <summary>
            Move the cursor before incoming labels (branches). This is the default behaviour. Emitted instructions will not cause labels to change targets.
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Goto(System.Int32,MonoMod.Cil.MoveType,System.Boolean)">
            <summary>
            Move the cursor to a target index. Supports negative indexing. See <see cref="M:MonoMod.Cil.ILCursor.Goto(Mono.Cecil.Cil.Instruction,MonoMod.Cil.MoveType,System.Boolean)"/>
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.GotoLabel(MonoMod.Cil.ILLabel,MonoMod.Cil.MoveType,System.Boolean)">
            <summary>
            Overload for <c>Goto(label.Target)</c>. <paramref name="moveType"/> defaults to MoveType.AfterLabel
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.GotoNext(MonoMod.Cil.MoveType,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Search forward and moves the cursor to the next sequence of instructions matching the corresponding predicates. See also <seealso cref="M:MonoMod.Cil.ILCursor.TryGotoNext(MonoMod.Cil.MoveType,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])"/>
            </summary>
            <returns>this</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If no match is found</exception>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.TryGotoNext(MonoMod.Cil.MoveType,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Search forward and moves the cursor to the next sequence of instructions matching the corresponding predicates.
            </summary>
            <returns>True if a match was found</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.GotoPrev(MonoMod.Cil.MoveType,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Search backward and moves the cursor to the next sequence of instructions matching the corresponding predicates. See also <seealso cref="M:MonoMod.Cil.ILCursor.TryGotoPrev(MonoMod.Cil.MoveType,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])"/>
            </summary>
            <returns>this</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If no match is found</exception>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.TryGotoPrev(MonoMod.Cil.MoveType,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Search backward and moves the cursor to the next sequence of instructions matching the corresponding predicates.
            </summary>
            <returns>True if a match was found</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.FindNext(MonoMod.Cil.ILCursor[]@,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Find the next occurences of a series of instructions matching the given set of predicates with gaps permitted.
            </summary>
            <param name="cursors">An array of cursors corresponding to each found instruction (MoveType.Before)</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If no match is found</exception>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.TryFindNext(MonoMod.Cil.ILCursor[]@,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Find the next occurences of a series of instructions matching the given set of predicates with gaps permitted.
            </summary>
            <param name="cursors">An array of cursors corresponding to each found instruction (MoveType.Before)</param>
            <returns>True if a match was found</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.FindPrev(MonoMod.Cil.ILCursor[]@,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Search backwards for occurences of a series of instructions matching the given set of predicates with gaps permitted.
            </summary>
            <param name="cursors">An array of cursors corresponding to each found instruction (MoveType.Before)</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If no match is found</exception>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.TryFindPrev(MonoMod.Cil.ILCursor[]@,System.Func{Mono.Cecil.Cil.Instruction,System.Boolean}[])">
            <summary>
            Search backwards for occurences of a series of instructions matching the given set of predicates with gaps permitted.
            </summary>
            <param name="cursors">An array of cursors corresponding to each found instruction (MoveType.Before)</param>
            <returns>True if a match was found</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.MarkLabel(MonoMod.Cil.ILLabel)">
            <summary>
            Set the target of a label to the current position (<c>label.Target = Next</c>) and moves after it.
            </summary>
            <param name="label">The label to mark</param>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.MarkLabel">
            <summary>
            Create a new label targetting the current position (<c>label.Target = Next</c>) and moves after it.
            </summary>
            <returns>The newly created label</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.DefineLabel">
            <summary>
            Create a new label for use with <see cref="M:MonoMod.Cil.ILCursor.MarkLabel(MonoMod.Cil.ILLabel)"/>
            </summary>
            <returns>A new label with no target</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Remove">
            <summary>
            Remove the Next instruction
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.RemoveRange(System.Int32)">
            <summary>
            Remove several instructions
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILCursor._Retarget(Mono.Cecil.Cil.Instruction,MonoMod.Cil.MoveType)">
            <summary>
            Move the cursor and all labels the cursor is positioned after to a target instruction
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.ParameterDefinition)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="parameter">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.Cil.VariableDefinition)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="variable">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.Cil.Instruction[])">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="targets">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.Cil.Instruction)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="target">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Double)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="value">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Single)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="value">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Int64)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="value">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.SByte)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="value">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Byte)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="value">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.String)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="value">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.FieldReference)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="field">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.CallSite)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="site">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.TypeReference)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="type">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Int32)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="value">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,Mono.Cecil.MethodReference)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="method">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="field">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Reflection.MethodBase)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="method">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Type)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="type">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit(Mono.Cecil.Cil.OpCode,System.Object)">
            <summary>
            Emit a new instruction at this cursor's current position.
            </summary>
            <param name="opcode">The instruction opcode.</param>
            <param name="operand">The instruction operand.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.Emit``1(Mono.Cecil.Cil.OpCode,System.String)">
            <summary>
            Emit a new instruction at this cursor's current position, accessing a given member.
            </summary>
            <typeparam name="T">The type in which the member is defined.</typeparam>
            <param name="opcode">The instruction opcode.</param>
            <param name="memberName">The accessed member name.</param>
            <returns>this</returns>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.AddReference``1(``0@)">
            <summary>
            Bind an arbitary object to an ILContext for static retrieval. See <see cref="M:MonoMod.Cil.ILContext.AddReference``1(``0@)"/>
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.EmitGetReference``1(System.Int32)">
            <summary>
            Emit the IL to retrieve a stored reference of type <typeparamref name="T"/> with the given <paramref name="id"/> and place it on the stack.
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.EmitReference``1(``0@)">
            <summary>
            Store an object in the reference store, and emit the IL to retrieve it and place it on the stack.
            </summary>
        </member>
        <member name="M:MonoMod.Cil.ILCursor.EmitDelegate``1(``0)">
            <summary>
            Emit the IL to invoke a delegate as if it were a method. Stack behaviour matches OpCodes.Call
            </summary>
        </member>
        <member name="T:MonoMod.Cil.ILLabel">
            <summary>
            A label to be used in ILContexts.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILLabel.Target">
            <summary>
            The target instruction this label points at.
            </summary>
        </member>
        <member name="P:MonoMod.Cil.ILLabel.Branches">
            <summary>
            All instructions using this label.
            </summary>
        </member>
        <member name="F:MonoMod.Logs.DebugLogInterpolatedStringHandler.MinimumArrayPoolLength">
            <summary>Minimum size array to rent from the pool.</summary>
            <remarks>Same as stack-allocation size used today by string.Format.</remarks>
        </member>
        <member name="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._arrayToReturnToPool">
            <summary>Array rented from the array pool and used to back <see cref="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._chars">
            <summary>The span to write into.</summary>
        </member>
        <member name="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._pos">
            <summary>Position at which to write the next character.</summary>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.Clear">
            <summary>Clears the handler, returning any rented array to the pool.</summary>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.AppendOrInsertAlignmentIfNeeded(System.Int32,System.Int32)">
            <summary>Handles adding any padding required for aligning a formatted value in an interpolation expression.</summary>
            <param name="startingPos">The position at which the written value started.</param>
            <param name="alignment">Non-zero minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.EnsureCapacityForAdditionalChars(System.Int32)">
            <summary>Ensures <see cref="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._chars"/> has the capacity to store <paramref name="additionalChars"/> beyond <see cref="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._pos"/>.</summary>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.GrowThenCopyString(System.String)">
            <summary>Fallback for fast path in <see cref="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.AppendStringDirect(System.String)"/> when there's not enough space in the destination.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.GrowThenCopySpan(System.ReadOnlySpan{System.Char})">
            <summary>Fallback for <see cref="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})"/> for when not enough space exists in the current buffer.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.Grow(System.Int32)">
            <summary>Grows <see cref="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._chars"/> to have the capacity to store at least <paramref name="additionalChars"/> beyond <see cref="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._pos"/>.</summary>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.Grow">
            <summary>Grows the size of <see cref="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="M:MonoMod.Logs.DebugLogInterpolatedStringHandler.GrowCore(System.UInt32)">
            <summary>Grow the size of <see cref="F:MonoMod.Logs.DebugLogInterpolatedStringHandler._chars"/> to at least the specified <paramref name="requiredMinCapacity"/>.</summary>
        </member>
        <member name="M:MonoMod.Logs.FormatIntoInterpolatedStringHandler.AppendOrInsertAlignmentIfNeeded(System.Int32,System.Int32)">
            <summary>Handles adding any padding required for aligning a formatted value in an interpolation expression.</summary>
            <param name="startingPos">The position at which the written value started.</param>
            <param name="alignment">Non-zero minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
        </member>
        <member name="F:MonoMod.Switches.RunningOnWine">
            <summary>
            Boolean. Forces <see cref="T:MonoMod.Utils.PlatformDetection"/> to detect that Windows is Wine.
            </summary>
        </member>
        <member name="F:MonoMod.Switches.DebugClr">
            <summary>
            Boolean. Tells MonoMod that it is running on a Debug or Checked build of CoreCLR.
            </summary>
            <remarks>
            MonoMod.Core, in its CoreCLR implementation, pokes into certain internal CLR datastructures. Some of these
            have a different layout in Release builds than in Debug or Checked builds, so MonoMod needs to know which
            type of build it is running on, and that is not detectable. MonoMod assumes Release builds by default,
            because that is the most common configuration.
            </remarks>
        </member>
        <member name="F:MonoMod.Switches.LogRecordHoles">
            <summary>
            Boolean. Forces the logger to always record the value of message holes.
            </summary>
        </member>
        <member name="F:MonoMod.Switches.LogInMemory">
            <summary>
            Boolean. Enables the in-memory logger.
            </summary>
        </member>
        <member name="F:MonoMod.Switches.LogSpam">
            <summary>
            Boolean. Enables the logging of <see cref="F:MonoMod.Logs.LogLevel.Spam"/> messages to default sinks (file and memory).
            </summary>
        </member>
        <member name="F:MonoMod.Switches.LogReplayQueueLength">
            <summary>
            Integer. Sets the length of the logger's replay queue, in log messages. If the value is zero (the default), the
            replay queue is disabled.
            </summary>
        </member>
        <member name="F:MonoMod.Switches.LogToFile">
            <summary>
            String. Enables the file sink of the logger. Contains the name of the log file to write. <c>-</c> indicates
            standard out.
            </summary>
        </member>
        <member name="F:MonoMod.Switches.LogToFileFilter">
            <summary>
            String. Provides a comma or semicolon separated list of sources to write to disk. If empty, all soruces are
            written. Sources are typically the MonoMod assembly name (e.g. <c>MonoMod.Utils</c> or <c>MonoMod.RuntimeDetour</c>).
            </summary>
        </member>
        <member name="F:MonoMod.Switches.DMDType">
            <summary>
            String. Specifies the backend to use for <see cref="T:MonoMod.Utils.DynamicMethodDefinition"/>s. Refer to <c>docs/Switches.md</c> for
            details.
            </summary>
        </member>
        <member name="F:MonoMod.Switches.DMDDebug">
            <summary>
            Boolean. Specifies the default value for <see cref="P:MonoMod.Utils.DynamicMethodDefinition.Debug"/>. Refer to <c>docs/Switches.md</c>
            for details.
            </summary>
        </member>
        <member name="F:MonoMod.Switches.DMDDumpTo">
            <summary>
            String. Specifies the directory to dump <see cref="T:MonoMod.Utils.DynamicMethodDefinition"/>s to for debugging. Refer to
            <c>docs/Switches.md</c> for details.
            </summary>
        </member>
        <member name="M:MonoMod.Switches.SetSwitchValue(System.String,System.Object)">
            <summary>
            Sets the value associated with a switch.
            </summary>
            <param name="switch">The switch to set the value of.</param>
            <param name="value">The value of the switch.</param>
        </member>
        <member name="M:MonoMod.Switches.ClearSwitchValue(System.String)">
            <summary>
            Clears the specified switch.
            </summary>
            <remarks>
            The primary use of this method is to enable switch lookups to fall back to reading <see cref="T:System.AppContext"/>, if
            that is available on the current platform.
            </remarks>
            <param name="switch">The switch to clear.</param>
        </member>
        <member name="T:Windows.Win32.Foundation.PCSTR">
            <summary>
            A pointer to a constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, decoding as UTF-8.
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string.
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array.
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string.
            </summary>
        </member>
        <member name="T:Windows.Win32.Interop">
            <content>
            Contains extern methods from "KERNEL32.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.Interop.GetSystemInfo(Windows.Win32.System.SystemInformation.SYSTEM_INFO@)">
            <inheritdoc cref="M:Windows.Win32.Interop.GetSystemInfo(Windows.Win32.System.SystemInformation.SYSTEM_INFO*)"/>
        </member>
        <member name="M:Windows.Win32.Interop.GetSystemInfo(Windows.Win32.System.SystemInformation.SYSTEM_INFO*)">
            <summary>Retrieves information about the current system.</summary>
            <param name="lpSystemInfo">
            <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/ns-sysinfoapi-system_info">SYSTEM_INFO</a> structure that receives the information.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsysteminfo#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/nf-sysinfoapi-getsysteminfo">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Interop.FreeLibrary(Windows.Win32.Foundation.HINSTANCE)">
            <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
            <param name="hLibModule">
            <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Interop.GetModuleHandle(System.String)">
            <inheritdoc cref="M:Windows.Win32.Interop.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.Interop.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)">
            <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</summary>
            <param name="lpModuleName">
            <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
            <para>If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandlew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandlew">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Interop.GetProcAddress(Windows.Win32.Foundation.HINSTANCE,System.String)">
            <inheritdoc cref="M:Windows.Win32.Interop.GetProcAddress(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCSTR)"/>
        </member>
        <member name="M:Windows.Win32.Interop.GetProcAddress(Windows.Win32.Foundation.HINSTANCE,Windows.Win32.Foundation.PCSTR)">
            <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
            <param name="hModule">
            <para>A handle to the DLL module that contains the function or variable. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function returns this handle. The <b>GetProcAddress</b> function does not retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getprocaddress#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            <para>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getprocaddress">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.Interop.LoadLibrary(System.String)">
            <inheritdoc cref="M:Windows.Win32.Interop.LoadLibrary(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.Interop.LoadLibrary(Windows.Win32.Foundation.PCWSTR)">
            <summary>Loads the specified module into the address space of the calling process.</summary>
            <param name="lpLibFileName">
            <para>The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies a full path, the function searches only that path for the module. If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks. If the function cannot find the  module, the function fails. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>. If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the module. If the function fails, the return value is NULL. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-loadlibraryw">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.System.SystemInformation.SYSTEM_INFO">
            <summary>Contains information about the current computer system. This includes the architecture and type of the processor, the number of processors in the system, the page size, and other such information.</summary>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/ns-sysinfoapi-system_info">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.dwPageSize">
            <summary>
            <para>The page size and the granularity of page protection and commitment. This is the page size used by the <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> function.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/ns-sysinfoapi-system_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.lpMinimumApplicationAddress">
            <summary>A pointer to the lowest memory address accessible to applications and dynamic-link libraries (DLLs).</summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.lpMaximumApplicationAddress">
            <summary>A pointer to the highest memory address accessible to applications and DLLs.</summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.dwActiveProcessorMask">
            <summary>A mask representing the set of processors configured into the system. Bit 0 is processor 0; bit 31 is processor 31.</summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.dwNumberOfProcessors">
            <summary>
            <para>The number of logical processors in the current group. To retrieve this value, use the <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation">GetLogicalProcessorInformation</a> function. <div class="alert"><b>Note</b>  For information about the  physical processors shared by logical processors, call <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformationex">GetLogicalProcessorInformationEx</a> with the <i>RelationshipType</i> parameter set to RelationProcessorPackage (3).</div> <div> </div></para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/ns-sysinfoapi-system_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.dwProcessorType">
            <summary>An obsolete member that is retained for compatibility. Use the <b>wProcessorArchitecture</b>, <b>wProcessorLevel</b>, and <b>wProcessorRevision</b> members to determine the type of processor.</summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.dwAllocationGranularity">
            <summary>The granularity for the starting address at which virtual memory can be allocated. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>.</summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.wProcessorLevel">
            <summary>
            <para>The architecture-dependent processor level. It should be used only for display purposes. To determine the feature set of a processor, use the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-isprocessorfeaturepresent">IsProcessorFeaturePresent</a> function. If <b>wProcessorArchitecture</b> is PROCESSOR_ARCHITECTURE_INTEL, <b>wProcessorLevel</b> is defined by the CPU vendor. If <b>wProcessorArchitecture</b> is PROCESSOR_ARCHITECTURE_IA64, <b>wProcessorLevel</b> is set to 1.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/ns-sysinfoapi-system_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.System.SystemInformation.SYSTEM_INFO.wProcessorRevision">
            <summary>
            <para>The architecture-dependent processor revision. The following table shows how the revision value is assembled for each type of processor architecture.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//sysinfoapi/ns-sysinfoapi-system_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
    </members>
</doc>
